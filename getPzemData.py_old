#!/usr/bin/python3

# Reading PZEM-004t power sensor (new version v3.0) through Modbus-RTU protocol over TTL UART
# Run as:
# python3 pzem_004t.py

# To install dependencies:
# pip install modbus-tk
# pip install pyserial

import serial
import modbus_tk.defines as cst
from modbus_tk import modbus_rtu
import schedule
import paho.mqtt.client as mqtt
import logging
import json
import time

from datetime import datetime
from pytz import timezone


# =================== Configuration ===============================
mqtt_host = "192.168.0.198"
mqtt_port = 1883
auto_discovery = True
discovery_topic = "homeassistant"
serial_port = "/dev/ttyPZEM"
base_topic = "pzem2mqtt/003"
local_tz = "Europe/Paris"
lwt_topic = base_topic + "/lwt"
# ==================================================================

logging.basicConfig(level=logging.INFO, format='   %(asctime)s %(levelname)-8s %(message)s')
logger = logging.getLogger()

def on_connect(client, userdata, flags, rc):
    """ Connection MQTT handler"""

    global lwt_topic
    logger.info("Connected to MQTT server with result code " + str(rc))

    client.publish(lwt_topic, "online", qos=1, retain=True)

def sendDiscoveryConfig(client):
    # global discovery_topic
    global auto_discovery
    logger.info("Set Home Assistant sensor definition")

    if auto_discovery:
        createPowerDevice(client, "0xff02398f98e9a322", "Plaque induction energy")
        createPowerDevice(client, "0xff021256faec456d", "Four energy")
        createPowerDevice(client, "0xffc5654ea54c8978", "Chauffage etage energy")


def createPowerDevice(client, component_id, component_label):
    global base_topic

    logger.info("Publish autodiscovery device to Home Assistant : {} [{}]".format(component_label, component_id))

    device = {
        "identifiers": [
            "pzem2mqtt_" + component_id
        ],
        "manufacturer": "Mamath + python + pzem004t",
        "model": "PZEM004T v3",
        "name": component_label
    }

    ## ///////////////////////////////////////////////////////////////////////////////////////////////////
    tag = "Energy"
    sendDiscoverySensor(
        client,
        device,
        component_id,
        component_label,
        tag,
        "energy",
        "kWh",
        "total_increasing")

    ## ///////////////////////////////////////////////////////////////////////////////////////////////////
    tag = "Tension"
    sendDiscoverySensor(
        client,
        device,
        component_id,
        component_label,
        tag,
        "voltage",
        "V",
        "measurement")

    ## ///////////////////////////////////////////////////////////////////////////////////////////////////
    tag = "Puissance"
    sendDiscoverySensor(
        client,
        device,
        component_id,
        component_label,
        tag,
        "power",
        "W",
        "measurement")

    ## ///////////////////////////////////////////////////////////////////////////////////////////////////
    tag = "Courant"
    sendDiscoverySensor(
        client,
        device,
        component_id,
        component_label,
        tag,
        "current",
        "A",
        "measurement")

    ## ///////////////////////////////////////////////////////////////////////////////////////////////////
    tag = "Index"
    sendDiscoverySensor(
        client,
        device,
        component_id,
        component_label,
        tag,
        "energy",
        "Wh",
        "total_increasing")

    ## ///////////////////////////////////////////////////////////////////////////////////////////////////
    tag = "Courant (mA)"
    sendDiscoverySensor(
        client,
        device,
        component_id,
        component_label,
        tag,
        "current",
        "mA",
        "measurement")

    ## ///////////////////////////////////////////////////////////////////////////////////////////////////
    tag = "Puissance Apparente"
    sendDiscoverySensor(
        client,
        device,
        component_id,
        component_label,
        tag,
        "apparent_power",
        "VA",
        "measurement")

    ## ///////////////////////////////////////////////////////////////////////////////////////////////////
    tag = "Facteur de puiss"
    sendDiscoverySensor(
        client,
        device,
        component_id,
        component_label,
        tag,
        "power_factor",
        "%",
        "measurement")

def sendDiscoverySensor(client, device, component_id, component_label, tag, device_class, unit_of_measurement, state_class):
    global discovery_topic
    global base_topic
    global lwt_topic

	# "entity_category": "config",

    entity_tag = tag.lower().replace(" ","_").replace("(","").replace(")","").replace(".","")
    entity_id = component_label.lower().replace(" ","_").replace("(","").replace(")","").replace(".","") 
    topic = discovery_topic + "/sensor/" + component_id + "/" + entity_tag +"/config"
    payload = {
        "availability_topic": lwt_topic,
        "device": device,
        "device_class": device_class,
        "name": tag,
        "has_entity_name": True,
        "state_class": state_class,
        "unique_id": "pzem2mqtt_" + component_id + "_" + entity_tag,
        "object_id": entity_id + "_" + entity_tag,
        "unit_of_measurement": unit_of_measurement,
        "state_topic": base_topic + "/" + entity_id,
        "value_template": "{{ value_json." + entity_tag + " }}",
        "json_attributes_topic": base_topic +"/" + entity_id,
        "attributes_template": "{{ value_json | tojson }}"
    }
    logger.info("Publish on topic : {}".format(topic))

    client.publish(topic, json.dumps(payload), 0, True)

    # return payload

def getPzem004t(rtu, id):

    try:
        data = rtu.execute(id, cst.READ_INPUT_REGISTERS,  0, 10)

        tension = round(data[0] / 10.0, 1)                        # [V]
        courant = round((data[1] + (data[2] << 16)) / 1000.0, 3)  # [A]
        courant_ma = round(data[1] + (data[2] << 16), 0)          # [mA]
        puissance = round((data[3] + (data[4] << 16)) / 10.0, 1)  # [W]
        energy = (data[5] + (data[6] << 16)) / 1000.0             # [kWh]
        index = (data[5] + (data[6] << 16))                       # [Wh]
        frequency = data[7] / 10.0                                # [Hz]
        facteurDePuiss = data[8] / 100.0                          # [%]
        puissanceApparente = round(courant * tension, 2)          # [VA]

        logger.debug("Index [Wh] : {0}".format(index))
        logger.debug("Tension [V] : {0}".format(tension))
        logger.debug("Courant [A] : {0}".format(courant))
        logger.debug("Courant [mA] : {0}".format(courant_ma))
        logger.debug("Puissance [W] : {0}".format(puissance))
        logger.debug("Energy [kWh] : {0}".format(energy))
        logger.debug("Frequency [Hz] : {0}".format(frequency))
        logger.debug("Facteur de Puiss. [%] : {0}".format(facteurDePuiss))
        logger.debug("Puissance Apparente [VA] : {0}".format(puissanceApparente))


        logger.info("Reading PZEM004T ok. Sensor n° {0}".format(id))
        jsondata={
                    "index": round(float(index)),
                    "courant": float(courant),
                    "courant_ma": float(courant_ma),
                    "energy": float(energy),
                    "puissance": round(float(puissance),1),
                    "power": round(float(puissance),1),
                    "tension": float(tension),
                    "frequency": float(frequency),
                    "facteur_de_puiss": float(facteurDePuiss),
                    "puissance_apparente": float(puissanceApparente)
                }
        return jsondata


    except:
        logger.error("Error reading PZEM004T. Sensor n° {0}".format(id))

        pass

def process(client, rtu):
    global base_topic
    global payload_chauffage
    global payload_chauffe_eau

    payload = getPzem004t(rtu, 1)
    if payload:
        # component_label = "Plaque induction energy"
        component_id = "plaque_induction_energy"
        client.publish(base_topic + "/" + component_id, json.dumps(payload), qos=0, retain=True)
    time.sleep(0.5)

    payload = getPzem004t(rtu, 2)
    if payload:
        # component_label = "Four energy"
        component_id = "four_energy"
        client.publish(base_topic + "/" + component_id, json.dumps(payload), qos=0, retain=True)
    time.sleep(0.5)

    payload = getPzem004t(rtu, 3)
    if payload:
        # component_label = "Chauffage etage energy"
        component_id = "chauffage_etage_energy"
        client.publish(base_topic + "/" + component_id, json.dumps(payload), qos=0, retain=True)
    time.sleep(0.5)

def main():

    global mqtt_host
    global mqtt_port
    global lwt_topic
    global serial

    logger.info(" ==== Starting pzem2mqtt 1.0 (mamath) === ")

    # MQTT configuration
    client = mqtt.Client()
    client.will_set(lwt_topic, "offline", qos=0, retain=True)
    client.on_connect = on_connect

    logger.info("Connection to mqtt broker : http://{}:{}".format(mqtt_host, mqtt_port))

    # client.on_log = on_log
    client.connect(mqtt_host, mqtt_port, keepalive=120)
    client.publish(lwt_topic, "online", qos=0, retain=True)

    time.sleep(4)
    sendDiscoveryConfig(client)

    # Connect to the slave
    serial = serial.Serial(
                        port=serial_port,
                        baudrate=9600,
                        bytesize=8,
                        parity='N',
                        stopbits=1,
                        xonxoff=0
                        )

    master = modbus_rtu.RtuMaster(serial)
    master.set_timeout(2.0)
    master.set_verbose(True)

    try:
        master.close()
    except:
        pass

    # schedule.every().day.at("00:00").do(process, client=client)
    # schedule.every().day.do(sendDiscoveryConfig, client=client)
    # schedule.every().minutes.do(process, client=client)
    schedule.every(5).seconds.do(process, client=client, rtu=master)

    client.loop_start()

    process(client, master)

    while True:
        schedule.run_pending()
        time.sleep(1)

if __name__ == "__main__":

    main()
